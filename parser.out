Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    UMINUS
    LS_PAREN
    RS_PAREN
    LF_PAREN
    RF_PAREN
    COMMA
    EQUAL
    GREATER
    LESS
    G_EQUAL
    L_EQUAL
    RETURN

Grammar

Rule 0     S' -> sentence
Rule 1     sentence -> statement SEMIC sentence
Rule 2     sentence -> empty
Rule 3     statement -> statement_b
Rule 4     statement -> statement_op
Rule 5     statement_b -> IF iexpression THEN iblock END
Rule 6     statement_b -> IF iexpression THEN iblock ELSE eblock END
Rule 7     statement_op -> word
Rule 8     iexpression -> expression
Rule 9     iblock -> istat SEMIC iblock
Rule 10    iblock -> empty
Rule 11    istat -> statement_b
Rule 12    istat -> iword
Rule 13    iword -> ID ASSIGN expression
Rule 14    iword -> INT ID
Rule 15    eblock -> estat SEMIC eblock
Rule 16    eblock -> empty
Rule 17    estat -> statement_b
Rule 18    estat -> eword
Rule 19    eword -> ID ASSIGN expression
Rule 20    eword -> INT ID
Rule 21    word -> ID ASSIGN expression
Rule 22    word -> INT ID
Rule 23    expression -> expression PLUS term
Rule 24    expression -> expression MINUS term
Rule 25    expression -> expression AND term
Rule 26    expression -> expression XOR term
Rule 27    expression -> INV term
Rule 28    expression -> term
Rule 29    term -> term TIMES factor
Rule 30    term -> term DIVIDE factor
Rule 31    term -> factor
Rule 32    factor -> NUMBER
Rule 33    factor -> LPAREN expression RPAREN
Rule 34    factor -> ID
Rule 35    empty -> <empty>

Terminals, with rules where they appear

AND                  : 25
ASSIGN               : 13 19 21
COMMA                : 
DIVIDE               : 30
ELSE                 : 6
END                  : 5 6
EQUAL                : 
GREATER              : 
G_EQUAL              : 
ID                   : 13 14 19 20 21 22 34
IF                   : 5 6
INT                  : 14 20 22
INV                  : 27
LESS                 : 
LF_PAREN             : 
LPAREN               : 33
LS_PAREN             : 
L_EQUAL              : 
MINUS                : 24
NUMBER               : 32
PLUS                 : 23
RETURN               : 
RF_PAREN             : 
RPAREN               : 33
RS_PAREN             : 
SEMIC                : 1 9 15
THEN                 : 5 6
TIMES                : 29
UMINUS               : 
XOR                  : 26
error                : 

Nonterminals, with rules where they appear

eblock               : 6 15
empty                : 2 10 16
estat                : 15
eword                : 18
expression           : 8 13 19 21 23 24 25 26 33
factor               : 29 30 31
iblock               : 5 6 9
iexpression          : 5 6
istat                : 9
iword                : 12
sentence             : 1 0
statement            : 1
statement_b          : 3 11 17
statement_op         : 4
term                 : 23 24 25 26 27 28 29 30
word                 : 7

Parsing method: LALR

state 0

    (0) S' -> . sentence
    (1) sentence -> . statement SEMIC sentence
    (2) sentence -> . empty
    (3) statement -> . statement_b
    (4) statement -> . statement_op
    (35) empty -> .
    (5) statement_b -> . IF iexpression THEN iblock END
    (6) statement_b -> . IF iexpression THEN iblock ELSE eblock END
    (7) statement_op -> . word
    (21) word -> . ID ASSIGN expression
    (22) word -> . INT ID

    $end            reduce using rule 35 (empty -> .)
    IF              shift and go to state 6
    ID              shift and go to state 8
    INT             shift and go to state 9

    sentence                       shift and go to state 1
    statement                      shift and go to state 2
    empty                          shift and go to state 3
    statement_b                    shift and go to state 4
    statement_op                   shift and go to state 5
    word                           shift and go to state 7

state 1

    (0) S' -> sentence .



state 2

    (1) sentence -> statement . SEMIC sentence

    SEMIC           shift and go to state 10


state 3

    (2) sentence -> empty .

    $end            reduce using rule 2 (sentence -> empty .)


state 4

    (3) statement -> statement_b .

    SEMIC           reduce using rule 3 (statement -> statement_b .)


state 5

    (4) statement -> statement_op .

    SEMIC           reduce using rule 4 (statement -> statement_op .)


state 6

    (5) statement_b -> IF . iexpression THEN iblock END
    (6) statement_b -> IF . iexpression THEN iblock ELSE eblock END
    (8) iexpression -> . expression
    (23) expression -> . expression PLUS term
    (24) expression -> . expression MINUS term
    (25) expression -> . expression AND term
    (26) expression -> . expression XOR term
    (27) expression -> . INV term
    (28) expression -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    INV             shift and go to state 14
    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    iexpression                    shift and go to state 11
    expression                     shift and go to state 12
    term                           shift and go to state 13
    factor                         shift and go to state 15

state 7

    (7) statement_op -> word .

    SEMIC           reduce using rule 7 (statement_op -> word .)


state 8

    (21) word -> ID . ASSIGN expression

    ASSIGN          shift and go to state 19


state 9

    (22) word -> INT . ID

    ID              shift and go to state 20


state 10

    (1) sentence -> statement SEMIC . sentence
    (1) sentence -> . statement SEMIC sentence
    (2) sentence -> . empty
    (3) statement -> . statement_b
    (4) statement -> . statement_op
    (35) empty -> .
    (5) statement_b -> . IF iexpression THEN iblock END
    (6) statement_b -> . IF iexpression THEN iblock ELSE eblock END
    (7) statement_op -> . word
    (21) word -> . ID ASSIGN expression
    (22) word -> . INT ID

    $end            reduce using rule 35 (empty -> .)
    IF              shift and go to state 6
    ID              shift and go to state 8
    INT             shift and go to state 9

    statement                      shift and go to state 2
    sentence                       shift and go to state 21
    empty                          shift and go to state 3
    statement_b                    shift and go to state 4
    statement_op                   shift and go to state 5
    word                           shift and go to state 7

state 11

    (5) statement_b -> IF iexpression . THEN iblock END
    (6) statement_b -> IF iexpression . THEN iblock ELSE eblock END

    THEN            shift and go to state 22


state 12

    (8) iexpression -> expression .
    (23) expression -> expression . PLUS term
    (24) expression -> expression . MINUS term
    (25) expression -> expression . AND term
    (26) expression -> expression . XOR term

    THEN            reduce using rule 8 (iexpression -> expression .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND             shift and go to state 25
    XOR             shift and go to state 26


state 13

    (28) expression -> term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor

    PLUS            reduce using rule 28 (expression -> term .)
    MINUS           reduce using rule 28 (expression -> term .)
    AND             reduce using rule 28 (expression -> term .)
    XOR             reduce using rule 28 (expression -> term .)
    THEN            reduce using rule 28 (expression -> term .)
    RPAREN          reduce using rule 28 (expression -> term .)
    SEMIC           reduce using rule 28 (expression -> term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 14

    (27) expression -> INV . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    term                           shift and go to state 29
    factor                         shift and go to state 15

state 15

    (31) term -> factor .

    TIMES           reduce using rule 31 (term -> factor .)
    DIVIDE          reduce using rule 31 (term -> factor .)
    PLUS            reduce using rule 31 (term -> factor .)
    MINUS           reduce using rule 31 (term -> factor .)
    AND             reduce using rule 31 (term -> factor .)
    XOR             reduce using rule 31 (term -> factor .)
    THEN            reduce using rule 31 (term -> factor .)
    RPAREN          reduce using rule 31 (term -> factor .)
    SEMIC           reduce using rule 31 (term -> factor .)


state 16

    (32) factor -> NUMBER .

    TIMES           reduce using rule 32 (factor -> NUMBER .)
    DIVIDE          reduce using rule 32 (factor -> NUMBER .)
    PLUS            reduce using rule 32 (factor -> NUMBER .)
    MINUS           reduce using rule 32 (factor -> NUMBER .)
    AND             reduce using rule 32 (factor -> NUMBER .)
    XOR             reduce using rule 32 (factor -> NUMBER .)
    THEN            reduce using rule 32 (factor -> NUMBER .)
    RPAREN          reduce using rule 32 (factor -> NUMBER .)
    SEMIC           reduce using rule 32 (factor -> NUMBER .)


state 17

    (33) factor -> LPAREN . expression RPAREN
    (23) expression -> . expression PLUS term
    (24) expression -> . expression MINUS term
    (25) expression -> . expression AND term
    (26) expression -> . expression XOR term
    (27) expression -> . INV term
    (28) expression -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    INV             shift and go to state 14
    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    expression                     shift and go to state 30
    term                           shift and go to state 13
    factor                         shift and go to state 15

state 18

    (34) factor -> ID .

    TIMES           reduce using rule 34 (factor -> ID .)
    DIVIDE          reduce using rule 34 (factor -> ID .)
    PLUS            reduce using rule 34 (factor -> ID .)
    MINUS           reduce using rule 34 (factor -> ID .)
    AND             reduce using rule 34 (factor -> ID .)
    XOR             reduce using rule 34 (factor -> ID .)
    THEN            reduce using rule 34 (factor -> ID .)
    RPAREN          reduce using rule 34 (factor -> ID .)
    SEMIC           reduce using rule 34 (factor -> ID .)


state 19

    (21) word -> ID ASSIGN . expression
    (23) expression -> . expression PLUS term
    (24) expression -> . expression MINUS term
    (25) expression -> . expression AND term
    (26) expression -> . expression XOR term
    (27) expression -> . INV term
    (28) expression -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    INV             shift and go to state 14
    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    expression                     shift and go to state 31
    term                           shift and go to state 13
    factor                         shift and go to state 15

state 20

    (22) word -> INT ID .

    SEMIC           reduce using rule 22 (word -> INT ID .)


state 21

    (1) sentence -> statement SEMIC sentence .

    $end            reduce using rule 1 (sentence -> statement SEMIC sentence .)


state 22

    (5) statement_b -> IF iexpression THEN . iblock END
    (6) statement_b -> IF iexpression THEN . iblock ELSE eblock END
    (9) iblock -> . istat SEMIC iblock
    (10) iblock -> . empty
    (11) istat -> . statement_b
    (12) istat -> . iword
    (35) empty -> .
    (5) statement_b -> . IF iexpression THEN iblock END
    (6) statement_b -> . IF iexpression THEN iblock ELSE eblock END
    (13) iword -> . ID ASSIGN expression
    (14) iword -> . INT ID

    END             reduce using rule 35 (empty -> .)
    ELSE            reduce using rule 35 (empty -> .)
    IF              shift and go to state 6
    ID              shift and go to state 37
    INT             shift and go to state 38

    iblock                         shift and go to state 32
    istat                          shift and go to state 33
    empty                          shift and go to state 34
    statement_b                    shift and go to state 35
    iword                          shift and go to state 36

state 23

    (23) expression -> expression PLUS . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    term                           shift and go to state 39
    factor                         shift and go to state 15

state 24

    (24) expression -> expression MINUS . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    term                           shift and go to state 40
    factor                         shift and go to state 15

state 25

    (25) expression -> expression AND . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    term                           shift and go to state 41
    factor                         shift and go to state 15

state 26

    (26) expression -> expression XOR . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    term                           shift and go to state 42
    factor                         shift and go to state 15

state 27

    (29) term -> term TIMES . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    factor                         shift and go to state 43

state 28

    (30) term -> term DIVIDE . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    factor                         shift and go to state 44

state 29

    (27) expression -> INV term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor

    PLUS            reduce using rule 27 (expression -> INV term .)
    MINUS           reduce using rule 27 (expression -> INV term .)
    AND             reduce using rule 27 (expression -> INV term .)
    XOR             reduce using rule 27 (expression -> INV term .)
    THEN            reduce using rule 27 (expression -> INV term .)
    RPAREN          reduce using rule 27 (expression -> INV term .)
    SEMIC           reduce using rule 27 (expression -> INV term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 30

    (33) factor -> LPAREN expression . RPAREN
    (23) expression -> expression . PLUS term
    (24) expression -> expression . MINUS term
    (25) expression -> expression . AND term
    (26) expression -> expression . XOR term

    RPAREN          shift and go to state 45
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND             shift and go to state 25
    XOR             shift and go to state 26


state 31

    (21) word -> ID ASSIGN expression .
    (23) expression -> expression . PLUS term
    (24) expression -> expression . MINUS term
    (25) expression -> expression . AND term
    (26) expression -> expression . XOR term

    SEMIC           reduce using rule 21 (word -> ID ASSIGN expression .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND             shift and go to state 25
    XOR             shift and go to state 26


state 32

    (5) statement_b -> IF iexpression THEN iblock . END
    (6) statement_b -> IF iexpression THEN iblock . ELSE eblock END

    END             shift and go to state 46
    ELSE            shift and go to state 47


state 33

    (9) iblock -> istat . SEMIC iblock

    SEMIC           shift and go to state 48


state 34

    (10) iblock -> empty .

    END             reduce using rule 10 (iblock -> empty .)
    ELSE            reduce using rule 10 (iblock -> empty .)


state 35

    (11) istat -> statement_b .

    SEMIC           reduce using rule 11 (istat -> statement_b .)


state 36

    (12) istat -> iword .

    SEMIC           reduce using rule 12 (istat -> iword .)


state 37

    (13) iword -> ID . ASSIGN expression

    ASSIGN          shift and go to state 49


state 38

    (14) iword -> INT . ID

    ID              shift and go to state 50


state 39

    (23) expression -> expression PLUS term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor

    PLUS            reduce using rule 23 (expression -> expression PLUS term .)
    MINUS           reduce using rule 23 (expression -> expression PLUS term .)
    AND             reduce using rule 23 (expression -> expression PLUS term .)
    XOR             reduce using rule 23 (expression -> expression PLUS term .)
    THEN            reduce using rule 23 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 23 (expression -> expression PLUS term .)
    SEMIC           reduce using rule 23 (expression -> expression PLUS term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 40

    (24) expression -> expression MINUS term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor

    PLUS            reduce using rule 24 (expression -> expression MINUS term .)
    MINUS           reduce using rule 24 (expression -> expression MINUS term .)
    AND             reduce using rule 24 (expression -> expression MINUS term .)
    XOR             reduce using rule 24 (expression -> expression MINUS term .)
    THEN            reduce using rule 24 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 24 (expression -> expression MINUS term .)
    SEMIC           reduce using rule 24 (expression -> expression MINUS term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 41

    (25) expression -> expression AND term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor

    PLUS            reduce using rule 25 (expression -> expression AND term .)
    MINUS           reduce using rule 25 (expression -> expression AND term .)
    AND             reduce using rule 25 (expression -> expression AND term .)
    XOR             reduce using rule 25 (expression -> expression AND term .)
    THEN            reduce using rule 25 (expression -> expression AND term .)
    RPAREN          reduce using rule 25 (expression -> expression AND term .)
    SEMIC           reduce using rule 25 (expression -> expression AND term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 42

    (26) expression -> expression XOR term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor

    PLUS            reduce using rule 26 (expression -> expression XOR term .)
    MINUS           reduce using rule 26 (expression -> expression XOR term .)
    AND             reduce using rule 26 (expression -> expression XOR term .)
    XOR             reduce using rule 26 (expression -> expression XOR term .)
    THEN            reduce using rule 26 (expression -> expression XOR term .)
    RPAREN          reduce using rule 26 (expression -> expression XOR term .)
    SEMIC           reduce using rule 26 (expression -> expression XOR term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 43

    (29) term -> term TIMES factor .

    TIMES           reduce using rule 29 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 29 (term -> term TIMES factor .)
    PLUS            reduce using rule 29 (term -> term TIMES factor .)
    MINUS           reduce using rule 29 (term -> term TIMES factor .)
    AND             reduce using rule 29 (term -> term TIMES factor .)
    XOR             reduce using rule 29 (term -> term TIMES factor .)
    THEN            reduce using rule 29 (term -> term TIMES factor .)
    RPAREN          reduce using rule 29 (term -> term TIMES factor .)
    SEMIC           reduce using rule 29 (term -> term TIMES factor .)


state 44

    (30) term -> term DIVIDE factor .

    TIMES           reduce using rule 30 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 30 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 30 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 30 (term -> term DIVIDE factor .)
    AND             reduce using rule 30 (term -> term DIVIDE factor .)
    XOR             reduce using rule 30 (term -> term DIVIDE factor .)
    THEN            reduce using rule 30 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 30 (term -> term DIVIDE factor .)
    SEMIC           reduce using rule 30 (term -> term DIVIDE factor .)


state 45

    (33) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    XOR             reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    SEMIC           reduce using rule 33 (factor -> LPAREN expression RPAREN .)


state 46

    (5) statement_b -> IF iexpression THEN iblock END .

    SEMIC           reduce using rule 5 (statement_b -> IF iexpression THEN iblock END .)


state 47

    (6) statement_b -> IF iexpression THEN iblock ELSE . eblock END
    (15) eblock -> . estat SEMIC eblock
    (16) eblock -> . empty
    (17) estat -> . statement_b
    (18) estat -> . eword
    (35) empty -> .
    (5) statement_b -> . IF iexpression THEN iblock END
    (6) statement_b -> . IF iexpression THEN iblock ELSE eblock END
    (19) eword -> . ID ASSIGN expression
    (20) eword -> . INT ID

    END             reduce using rule 35 (empty -> .)
    IF              shift and go to state 6
    ID              shift and go to state 56
    INT             shift and go to state 57

    eblock                         shift and go to state 51
    estat                          shift and go to state 52
    empty                          shift and go to state 53
    statement_b                    shift and go to state 54
    eword                          shift and go to state 55

state 48

    (9) iblock -> istat SEMIC . iblock
    (9) iblock -> . istat SEMIC iblock
    (10) iblock -> . empty
    (11) istat -> . statement_b
    (12) istat -> . iword
    (35) empty -> .
    (5) statement_b -> . IF iexpression THEN iblock END
    (6) statement_b -> . IF iexpression THEN iblock ELSE eblock END
    (13) iword -> . ID ASSIGN expression
    (14) iword -> . INT ID

    END             reduce using rule 35 (empty -> .)
    ELSE            reduce using rule 35 (empty -> .)
    IF              shift and go to state 6
    ID              shift and go to state 37
    INT             shift and go to state 38

    istat                          shift and go to state 33
    iblock                         shift and go to state 58
    empty                          shift and go to state 34
    statement_b                    shift and go to state 35
    iword                          shift and go to state 36

state 49

    (13) iword -> ID ASSIGN . expression
    (23) expression -> . expression PLUS term
    (24) expression -> . expression MINUS term
    (25) expression -> . expression AND term
    (26) expression -> . expression XOR term
    (27) expression -> . INV term
    (28) expression -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    INV             shift and go to state 14
    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    expression                     shift and go to state 59
    term                           shift and go to state 13
    factor                         shift and go to state 15

state 50

    (14) iword -> INT ID .

    SEMIC           reduce using rule 14 (iword -> INT ID .)


state 51

    (6) statement_b -> IF iexpression THEN iblock ELSE eblock . END

    END             shift and go to state 60


state 52

    (15) eblock -> estat . SEMIC eblock

    SEMIC           shift and go to state 61


state 53

    (16) eblock -> empty .

    END             reduce using rule 16 (eblock -> empty .)


state 54

    (17) estat -> statement_b .

    SEMIC           reduce using rule 17 (estat -> statement_b .)


state 55

    (18) estat -> eword .

    SEMIC           reduce using rule 18 (estat -> eword .)


state 56

    (19) eword -> ID . ASSIGN expression

    ASSIGN          shift and go to state 62


state 57

    (20) eword -> INT . ID

    ID              shift and go to state 63


state 58

    (9) iblock -> istat SEMIC iblock .

    END             reduce using rule 9 (iblock -> istat SEMIC iblock .)
    ELSE            reduce using rule 9 (iblock -> istat SEMIC iblock .)


state 59

    (13) iword -> ID ASSIGN expression .
    (23) expression -> expression . PLUS term
    (24) expression -> expression . MINUS term
    (25) expression -> expression . AND term
    (26) expression -> expression . XOR term

    SEMIC           reduce using rule 13 (iword -> ID ASSIGN expression .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND             shift and go to state 25
    XOR             shift and go to state 26


state 60

    (6) statement_b -> IF iexpression THEN iblock ELSE eblock END .

    SEMIC           reduce using rule 6 (statement_b -> IF iexpression THEN iblock ELSE eblock END .)


state 61

    (15) eblock -> estat SEMIC . eblock
    (15) eblock -> . estat SEMIC eblock
    (16) eblock -> . empty
    (17) estat -> . statement_b
    (18) estat -> . eword
    (35) empty -> .
    (5) statement_b -> . IF iexpression THEN iblock END
    (6) statement_b -> . IF iexpression THEN iblock ELSE eblock END
    (19) eword -> . ID ASSIGN expression
    (20) eword -> . INT ID

    END             reduce using rule 35 (empty -> .)
    IF              shift and go to state 6
    ID              shift and go to state 56
    INT             shift and go to state 57

    estat                          shift and go to state 52
    eblock                         shift and go to state 64
    empty                          shift and go to state 53
    statement_b                    shift and go to state 54
    eword                          shift and go to state 55

state 62

    (19) eword -> ID ASSIGN . expression
    (23) expression -> . expression PLUS term
    (24) expression -> . expression MINUS term
    (25) expression -> . expression AND term
    (26) expression -> . expression XOR term
    (27) expression -> . INV term
    (28) expression -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . LPAREN expression RPAREN
    (34) factor -> . ID

    INV             shift and go to state 14
    NUMBER          shift and go to state 16
    LPAREN          shift and go to state 17
    ID              shift and go to state 18

    expression                     shift and go to state 65
    term                           shift and go to state 13
    factor                         shift and go to state 15

state 63

    (20) eword -> INT ID .

    SEMIC           reduce using rule 20 (eword -> INT ID .)


state 64

    (15) eblock -> estat SEMIC eblock .

    END             reduce using rule 15 (eblock -> estat SEMIC eblock .)


state 65

    (19) eword -> ID ASSIGN expression .
    (23) expression -> expression . PLUS term
    (24) expression -> expression . MINUS term
    (25) expression -> expression . AND term
    (26) expression -> expression . XOR term

    SEMIC           reduce using rule 19 (eword -> ID ASSIGN expression .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24
    AND             shift and go to state 25
    XOR             shift and go to state 26

